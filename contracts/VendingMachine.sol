// SPDX-License-Identifier: MIT
// This line specifies the license under which this code is released.
// MIT is a permissive open-source license.

// This line declares the version of the Solidity compiler to be used.
// '^0.8.9' means it will use compiler version 0.8.9 or any later patch version (e.g., 0.8.10, 0.8.11) but not 0.9.0 or higher.
pragma solidity ^0.8.9;

/**
 * @title VendingMachine
 * @dev A smart contract that simulates a vending machine allowing users to purchase items with Ether.
 * It supports multiple items, owner-specific functions for management, and events for tracking actions.
 * This contract is designed for educational purposes with extensive comments.
 */
contract VendingMachine {
    // --- State Variables ---

    // `owner` stores the Ethereum address of the account that deployed the contract.
    // Only the owner can perform certain administrative actions like adding items or withdrawing funds.
    address public owner;

    // Tracks total revenue generated by the vending machine
    uint public totalRevenue;

    // Tracks total number of items sold across all types
    uint public totalItemsSold = 0;

    // Track when the contract was deployed (timestamp in seconds since Unix epoch)
    uint public deploymentTimestamp;

    // Safety feature to pause all purchases if needed
    bool public isPaused;

    // Discount rates for loyal customers (in percentage points, e.g., 10 = 10% discount)
    mapping(address => uint) public loyaltyDiscounts;

    // Structure to record details of each purchase
    struct PurchaseRecord {
        uint timestamp;     // When the purchase occurred
        uint itemId;        // Which item was purchased
        uint quantity;      // How many were purchased
        uint amountPaid;    // Total ETH paid (after discounts)
    }

    // Maps user addresses to their purchase history
    mapping(address => PurchaseRecord[]) private purchaseHistory;

    // --- Item Management ---

    // Structure representing an item in the vending machine
    struct Item {
        string name;        // Human-readable name (e.g., "Soda")
        uint price;        // Price in wei (1 ether = 10^18 wei)
        uint supply;        // Current inventory count
        bool isActive;      // Whether item can be purchased
        string imageURI;    // Optional link to item image (for UI)
    }

    // Array of all items in the machine
    Item[] public items;

    // Tracks sales per item (itemId => units sold)
    mapping(uint => uint) public itemSales;

    // --- Access Control ---

    // List of admin addresses with special privileges
    address[] public admins;

    // Quick lookup to check if an address is admin
    mapping(address => bool) public isAdmin;

    // Multi-signature implementation for sensitive admin actions
    struct AdminAction {
        bytes32 actionHash;             // Hash of the proposed action
        uint approvals;                // Current number of approvals
        mapping(address => bool) hasApproved;  // Which admins have approved
        bool executed;                  // Whether action was executed
    }

    // Number of approvals needed to execute an admin action
    uint public requiredApprovals = 2;

    // Counter for tracking admin action proposals
    uint public actionCounter;

    // Stores pending admin actions by ID
    mapping(uint => AdminAction) public pendingActions;

    // --- Events ---
    // Events are emitted to log important contract activities

    // Emitted when an item is successfully purchased
    event ItemPurchased(address indexed buyer, uint indexed itemId, string itemName, uint quantity, uint newSupplyForItem);

    // Emitted when a new item is added to the machine
    event ItemAdded(uint indexed itemId, string name, uint price, uint supply);

    // Emitted when item details are updated
    event ItemUpdated(uint indexed itemId, string name, uint price, uint supply);

    // Emitted when contract is paused for maintenance
    event ContractPaused(address by);

    // Emitted when contract is unpaused
    event ContractUnpaused(address by);

    // Emitted when a discount is applied to a purchase
    event DiscountApplied(address indexed user, uint itemId, uint discountPercentage);

    // Emitted when new admin is added
    event AdminAdded(address indexed newAdmin);

    // Emitted when admin is removed
    event AdminRemoved(address indexed admin);

    // Emitted when new admin action is proposed
    event AdminActionProposed(uint indexed actionId, bytes32 actionHash);

    // Emitted when admin approves an action
    event AdminActionApproved(uint indexed actionId, address approver);

    // Emitted when admin action is executed
    event AdminActionExecuted(uint indexed actionId);

    // --- Constructor ---
    // Runs once when contract is deployed
    constructor() {
        // Set contract deployer as owner
        owner = msg.sender;

        // Owner is also an admin by default
        isAdmin[msg.sender] = true;
        admins.push(msg.sender);

        // Record deployment time
        deploymentTimestamp = block.timestamp;

        // Initialize with default items
        _addItem("Soda", 0.0005 ether, 50, "ipfs://QmSoda");
        _addItem("Chips", 0.0003 ether, 75, "ipfs://QmChips");
        _addItem("Candy Bar", 0.0002 ether, 100, "ipfs://QmCandy");
    }

    // --- Modifiers ---
    // Reusable guards for functions

    /**
     * @dev Restrict access to only the contract owner
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }

    /**
     * @dev Restrict access to only admin accounts
     */
    modifier onlyAdmin() {
        require(isAdmin[msg.sender] || msg.sender == owner, "Only admin can call this function");
        _;
    }

    /**
     * @dev Ensure contract is not paused
     */
    modifier whenNotPaused() {
        require(!isPaused, "Contract is paused");
        _;
    }

    /**
     * @dev Validate item exists and is active
     */
    modifier validItem(uint _itemId) {
        require(_itemId < items.length, "Invalid item ID");
        require(items[_itemId].isActive, "Item is not active");
        _;
    }

    // --- Internal Functions ---
    // Not directly callable from outside

    /**
     * @dev Internal helper to add new item
     */
    function _addItem(string memory _name, uint _price, uint _supply, string memory _imageURI) internal {
        items.push(Item({
            name: _name,
            price: _price,
            supply: _supply,
            isActive: true,
            imageURI: _imageURI
        }));
        emit ItemAdded(items.length - 1, _name, _price, _supply);
    }

    /**
     * @dev Calculate price after applying loyalty discount
     */
    function _calculateDiscountedPrice(uint _itemId, address _buyer) internal view returns (uint) {
        uint discount = loyaltyDiscounts[_buyer];
        if (discount == 0) return items[_itemId].price;

        uint discountAmount = (items[_itemId].price * discount) / 100;
        return items[_itemId].price - discountAmount;
    }

    /**
     * @dev Record purchase in user's history
     */
    function _recordPurchase(address _buyer, uint _itemId, uint _quantity, uint _amountPaid) internal {
        purchaseHistory[_buyer].push(PurchaseRecord({
            timestamp: block.timestamp,
            itemId: _itemId,
            quantity: _quantity,
            amountPaid: _amountPaid
        }));
    }

    // --- Public/External Functions ---
    // Callable by users or other contracts

    /**
     * @dev Add new item to vending machine
     * @param _name Display name of item
     * @param _price Cost in wei
     * @param _supply Initial inventory count
     * @param _imageURI Optional image link
     */
    function addItem(string memory _name, uint _price, uint _supply, string memory _imageURI) public onlyAdmin whenNotPaused {
        require(bytes(_name).length > 0, "Name cannot be empty");
        require(_price > 0, "Price must be greater than 0");
        require(_supply > 0, "Supply must be greater than 0");

        _addItem(_name, _price, _supply, _imageURI);
    }

    /**
     * @dev Update existing item details
     */
    function updateItem(uint _itemId, string memory _name, uint _price, uint _supply, bool _isActive, string memory _imageURI)
        public
        onlyAdmin
        whenNotPaused
    {
        require(_itemId < items.length, "Invalid item ID");
        require(bytes(_name).length > 0, "Name cannot be empty");
        require(_price > 0, "Price must be greater than 0");

        items[_itemId].name = _name;
        items[_itemId].price = _price;
        items[_itemId].supply = _supply;
        items[_itemId].isActive = _isActive;
        items[_itemId].imageURI = _imageURI;

        emit ItemUpdated(_itemId, _name, _price, _supply);
    }

    /**
     * @dev Purchase items from the machine
     * @param _itemId ID of item to purchase
     * @param _quantity Number to purchase
     */
    function purchaseItem(uint _itemId, uint _quantity)
        public
        payable
        whenNotPaused
        validItem(_itemId)
    {
        require(_quantity > 0, "Quantity must be greater than 0");

        Item storage selectedItem = items[_itemId];
        require(selectedItem.supply >= _quantity, "Not enough supply");

        uint totalPrice = _calculateDiscountedPrice(_itemId, msg.sender) * _quantity;
        require(msg.value >= totalPrice, "Insufficient payment");

        // Update state
        selectedItem.supply -= _quantity;
        totalItemsSold += _quantity;
        itemSales[_itemId] += _quantity;
        totalRevenue += totalPrice;

        // Record purchase
        _recordPurchase(msg.sender, _itemId, _quantity, totalPrice);

        // Refund excess payment
        if (msg.value > totalPrice) {
            payable(msg.sender).transfer(msg.value - totalPrice);
        }

        emit ItemPurchased(msg.sender, _itemId, selectedItem.name, _quantity, selectedItem.supply);
    }

    /**
     * @dev Purchase multiple items in single transaction
     * @param _itemIds Array of item IDs
     * @param _quantities Corresponding quantities
     */
    function bulkPurchase(uint[] memory _itemIds, uint[] memory _quantities)
        public
        payable
        whenNotPaused
    {
        require(_itemIds.length == _quantities.length, "Arrays must be same length");
        require(_itemIds.length > 0, "Must purchase at least one item");

        uint totalCost = 0;

        // Calculate total cost
        for (uint i = 0; i < _itemIds.length; i++) {
            require(_itemIds[i] < items.length, "Invalid item ID");
            require(items[_itemIds[i]].isActive, "Item is not active");
            require(_quantities[i] > 0, "Quantity must be greater than 0");
            require(items[_itemIds[i]].supply >= _quantities[i], "Not enough supply");

            totalCost += _calculateDiscountedPrice(_itemIds[i], msg.sender) * _quantities[i];
        }

        require(msg.value >= totalCost, "Insufficient payment");

        // Process purchases
        for (uint i = 0; i < _itemIds.length; i++) {
            uint itemId = _itemIds[i];
            uint quantity = _quantities[i];
            uint itemPrice = _calculateDiscountedPrice(itemId, msg.sender) * quantity;

            // Update state
            items[itemId].supply -= quantity;
            totalItemsSold += quantity;
            itemSales[itemId] += quantity;

            // Record purchase
            _recordPurchase(msg.sender, itemId, quantity, itemPrice);

            emit ItemPurchased(msg.sender, itemId, items[itemId].name, quantity, items[itemId].supply);
        }

        totalRevenue += totalCost;

        // Refund excess payment
        if (msg.value > totalCost) {
            payable(msg.sender).transfer(msg.value - totalCost);
        }
    }

    /**
     * @dev Set discount percentage for customer
     * @param _customer Address to receive discount
     * @param _discountPercentage Discount amount (0-100)
     */
    function setLoyaltyDiscount(address _customer, uint _discountPercentage) public onlyAdmin {
        require(_discountPercentage <= 100, "Discount cannot exceed 100%");
        loyaltyDiscounts[_customer] = _discountPercentage;
    }

    /**
     * @dev Pause all purchases (emergency stop)
     */
    function pauseContract() public onlyAdmin {
        isPaused = true;
        emit ContractPaused(msg.sender);
    }

    /**
     * @dev Resume normal operations
     */
    function unpauseContract() public onlyAdmin {
        isPaused = false;
        emit ContractUnpaused(msg.sender);
    }

    /**
     * @dev Add new admin (owner can do directly, others need multi-sig)
     * @param _admin Address to grant admin privileges
     */
    function addAdmin(address _admin) public {
        if (msg.sender == owner) {
            // Owner can add admins directly
            _addAdmin(_admin);
        } else if (isAdmin[msg.sender]) {
            // Other admins need to propose and get approvals
            bytes32 actionHash = keccak256(abi.encodePacked("addAdmin", _admin));
            _proposeAdminAction(actionHash);
        } else {
            revert("Not authorized");
        }
    }

    /**
     * @dev Internal helper to add admin
     */
    function _addAdmin(address _admin) internal {
        require(_admin != address(0), "Invalid address");
        require(!isAdmin[_admin], "Already an admin");

        admins.push(_admin);
        isAdmin[_admin] = true;

        emit AdminAdded(_admin);
    }

    /**
     * @dev Propose new admin action requiring multi-sig
     */
    function _proposeAdminAction(bytes32 _actionHash) internal returns (uint) {
        uint actionId = actionCounter++;
        AdminAction storage action = pendingActions[actionId];
        action.actionHash = _actionHash;
        action.hasApproved[msg.sender] = true;
        action.approvals = 1;

        emit AdminActionProposed(actionId, _actionHash);
        return actionId;
    }

    /**
     * @dev Approve pending admin action
     * @param _actionId ID of action to approve
     */
    function approveAdminAction(uint _actionId) public onlyAdmin {
        AdminAction storage action = pendingActions[_actionId];

        require(!action.executed, "Action already executed");
        require(!action.hasApproved[msg.sender], "Already approved");

        action.approvals += 1;
        action.hasApproved[msg.sender] = true;

        emit AdminActionApproved(_actionId, msg.sender);

        // Execute if enough approvals
        if (action.approvals >= requiredApprovals) {
            action.executed = true;
            emit AdminActionExecuted(_actionId);
            // Action execution would be implemented here
        }
    }

    /**
     * @dev Get user's purchase history
     * @param _user Address to query
     * @param _startIndex Starting index in history array
     * @param _count Number of records to return
     */
    function getPurchaseHistory(address _user, uint _startIndex, uint _count)
        public
        view
        returns (uint[] memory timestamps, uint[] memory itemIds, uint[] memory quantities, uint[] memory amounts)
    {
        // Only owner, the user themselves, or admins can view purchase history
        require(msg.sender == owner || msg.sender == _user || isAdmin[msg.sender], "Not authorized");

        PurchaseRecord[] storage history = purchaseHistory[_user];

        // Validate indices
        require(_startIndex < history.length, "Start index out of bounds");
        uint endIndex = _startIndex + _count;
        if (endIndex > history.length) {
            endIndex = history.length;
        }

        uint resultCount = endIndex - _startIndex;

        // Initialize return arrays
        timestamps = new uint[](resultCount);
        itemIds = new uint[](resultCount);
        quantities = new uint[](resultCount);
        amounts = new uint[](resultCount);

        // Populate return arrays
        for (uint i = 0; i < resultCount; i++) {
            PurchaseRecord storage record = history[_startIndex + i];
            timestamps[i] = record.timestamp;
            itemIds[i] = record.itemId;
            quantities[i] = record.quantity;
            amounts[i] = record.amountPaid;
        }

        return (timestamps, itemIds, quantities, amounts);
    }

    /**
     * @dev Withdraw contract balance to owner
     * @param _amount Amount to withdraw (0 = withdraw all)
     */
    function withdrawFunds(uint _amount) public onlyOwner {
        uint amount = _amount;
        if (amount == 0) {
            amount = address(this).balance;
        }

        require(amount <= address(this).balance, "Insufficient contract balance");
        payable(owner).transfer(amount);
    }

    /**
     * @dev Get contract statistics
     */
    function getContractStats() public view returns (
        uint itemCount,
        uint totalSold,
        uint totalRev,
        uint contractBalance,
        uint contractAge
    ) {
        return (
            items.length,
            totalItemsSold,
            totalRevenue,
            address(this).balance,
            block.timestamp - deploymentTimestamp
        );
    }

    /**
     * @dev Get total number of items (for frontend compatibility)
     */
    function getNumberOfItems() public view returns (uint) {
        return items.length;
    }

    /**
     * @dev Get item details (for frontend compatibility)
     * @param _itemId ID of the item to query
     */
    function getItemDetails(uint _itemId) public view returns (string memory name, uint price, uint supply) {
        require(_itemId < items.length, "Invalid item ID");
        Item storage item = items[_itemId];
        return (item.name, item.price, item.supply);
    }

    /**
     * @dev Get user's balance for a specific item (for frontend compatibility)
     * @param _itemId ID of the item
     * @param _user Address of the user
     */
    function getItemBalance(uint _itemId, address _user) public view returns (uint) {
        require(_itemId < items.length, "Invalid item ID");

        // Count how many of this item the user has purchased
        PurchaseRecord[] storage history = purchaseHistory[_user];
        uint balance = 0;

        for (uint i = 0; i < history.length; i++) {
            if (history[i].itemId == _itemId) {
                balance += history[i].quantity;
            }
        }

        return balance;
    }



    // --- Fallback Functions ---

    /**
     * @dev Accept plain ETH transfers
     */
    receive() external payable {
        // Accept ETH deposits
    }

    /**
     * @dev Catch-all for unknown function calls with ETH
     */
    fallback() external payable {
        // Accept ETH when called with non-existent function
    }
}